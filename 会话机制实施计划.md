### **项目会话（Session）机制实施计划**

#### **1. 总体目标与思路**

核心目标是为每个用户（或每个浏览器会话）创建一个隔离的数据空间。用户上传和查询的所有数据都将与一个唯一的 `session_id` 绑定。当会话过期时，与该 `session_id` 关联的所有数据（包括PostgreSQL中的文件记录和Pinecone中的向量）将被自动清除。

**实现思路：**

1.  **前端生成和管理 `session_id`**：当用户首次访问时，在浏览器端生成一个唯一的ID（如UUID），并存储在 `localStorage` 中。
2.  **API请求传递 `session_id`**：前端在每次向后端发送请求时，都通过HTTP Header（例如 `X-Session-Id`）将此ID传递给后端。
3.  **后端数据隔离**：所有后端服务（文件上传、聊天、查询）都必须基于传入的 `session_id` 来操作数据库，确保数据的严格隔离。
4.  **会话过期与自动清理**：引入一个独立的会话表来记录每个 `session_id` 的过期时间，并使用一个定时任务（Cron Job）来定期清理过期数据。

---

#### **2. 数据库变更**

##### **2.1. PostgreSQL 数据库**

我们需要新增一个 `sessions` 表来管理会话的生命周期，并给现有的 `files` 表增加一个 `session_id` 字段用于数据隔离。

**a) 新增 `sessions` 表**
此表用于存储每个会话的过期时间。

**b) 修改 `files` 表**
添加 `session_id` 字段，并建立外键关联到 `sessions` 表。

**Drizzle Schema 更新 (`src/db/schema.ts`)**:
```typescript
import { pgTable, serial, varchar, timestamp, text } from "drizzle-orm/pg-core";

// 1. 新增 sessions 表
export const sessionsTable = pgTable("sessions", {
  id: text('id').primaryKey(), // 将使用前端生成的UUID，因此类型为text
  expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),
});

// 2. 修改现有的 fileTable
export const fileTable = pgTable("files", {
  id: serial('id').primaryKey(),
  fileName: varchar('file_name').notNull(),
  fileKey: varchar('file_key').notNull(),
  createdAt: timestamp('createdAt').defaultNow(),
  // 新增 sessionId 字段，并设置外键，实现级联删除
  sessionId: text('session_id').notNull().references(() => sessionsTable.id, { onDelete: 'cascade' }),
});

export type FileModel = typeof fileTable.$inferSelect;
export type SessionModel = typeof sessionsTable.$inferSelect;
```
**变更说明**:
*   `sessionsTable.id` 直接用作 `session_id`，类型为 `text`。
*   在 `fileTable` 中添加的 `sessionId` 字段设置了 `onDelete: 'cascade'`。这意味着当一个会话从 `sessionsTable` 中被删除时，所有与之关联的文件记录也会在PostgreSQL中被自动删除。

##### **2.2. Pinecone 向量数据库**

**您的提问：我的向量数据库需要新增相关字段吗？**

**回答：不需要新增“字段”（因为向量数据库没有固定的列），但需要在“元数据（Metadata）”中添加 `session_id`。**

Pinecone通过元数据（Metadata）来实现过滤查询。我们将在每个向量的元数据中都包含其所属的 `session_id`。

**Upsert（上传）到Pinecone时的数据结构示例**:
```json
{
  "id": "vector-id-123",
  "values": [0.1, 0.2, 0.3, ...],
  "metadata": {
    "text": "这是文档的一个片段...",
    "file_key": "some-file-key",
    "session_id": "user-session-uuid-abcde" // 在这里添加 session_id
  }
}
```

---

#### **3. 后端 API 变更**

##### **3.1. 新增API：会话管理**

创建一个新的API路由 `POST /api/session` 用于创建或更新会话的过期时间。

*   **请求体**: `{ "sessionId": "user-session-uuid-abcde", "durationInHours": 24 }`
*   **逻辑**:
    1.  接收 `sessionId` 和 `durationInHours`。
    2.  计算出 `expiresAt` 时间。
    3.  在 `sessionsTable` 中执行 "Upsert" 操作：如果 `sessionId` 已存在，则更新 `expiresAt`；如果不存在，则创建新记录。

##### **3.2. 修改现有API**

所有现有的API都需要修改，以强制执行基于 `session_id` 的数据隔离。

*   **`/api/upload`**:
    1.  从请求头 `X-Session-Id` 中获取 `sessionId`。
    2.  在向 `fileTable` 插入数据时，必须包含 `sessionId`。
    3.  在向 Pinecone `upsert` 向量时，必须在元数据中包含 `session_id`。

*   **`/api/chat`**:
    1.  从请求头 `X-Session-Id` 中获取 `sessionId`。
    2.  在查询 Pinecone 时，必须添加 `filter` 条件，只在当前会话的向量中搜索。
        ```javascript
        // Pinecone 查询示例
        await pc.index('chatbot').query({
          topK: 3,
          vector: queryVector,
          filter: {
            'session_id': { '$eq': sessionId } // 关键的过滤条件
          },
          includeMetadata: true,
        });
        ```

*   **`/api/get-files`**:
    1.  从请求头 `X-Session-Id` 中获取 `sessionId`。
    2.  查询 `fileTable` 时，必须添加 `WHERE session_id = ?` 条件。

*   **`/api/files/[id]` (删除)**:
    1.  从请求头 `X-Session-Id` 中获取 `sessionId`。
    2.  从 `fileTable` 删除文件前，必须验证该文件属于当前 `sessionId`。
    3.  从 Pinecone 删除向量时，也需要基于 `file_key` 和 `session_id` 进行删除。

---

#### **4. 自动删除机制 (Cron Job)**

我们将使用 **Vercel Cron Jobs** 来实现自动清理。

1.  **创建清理API**: 新增一个API路由 `GET /api/cron/cleanup-sessions`。为了安全，此API应配置为只能由Vercel的Cron服务调用（通过检查特定的 `Authorization` 头）。
2.  **API逻辑**:
    a.  查询 `sessionsTable` 中所有 `expiresAt` 小于当前时间的记录，获取所有过期的 `sessionId` 列表。
    b.  **批量删除Pinecone数据**: 遍历过期的 `sessionId` 列表，调用 Pinecone 的 `delete` 方法，并使用 `filter` 按 `session_id` 批量删除向量。
        ```javascript
        // Pinecone 批量删除示例
        await pc.index('chatbot').deleteMany({
          'session_id': { '$in': expiredSessionIds }
        });
        ```
    c.  **批量删除PostgreSQL数据**: 在 `sessionsTable` 中删除这些过期的会话记录。由于我们设置了 `onDelete: 'cascade'`，相关的 `files` 记录会被自动删除。
3.  **配置Vercel Cron Job**: 在 `vercel.json` 文件中添加配置，让Vercel每天（或每小时）定时调用 `/api/cron/cleanup-sessions`。

    **`vercel.json` 示例**:
    ```json
    {
      "crons": [
        {
          "path": "/api/cron/cleanup-sessions",
          "schedule": "0 0 * * *" // 每天午夜执行一次
        }
      ]
    }
    ```

---

#### **5. 前端变更**

1.  **会话ID管理**:
    *   在应用加载时，检查 `localStorage` 中是否存在 `session_id`。
    *   如果不存在，使用 `crypto.randomUUID()` 生成一个新的ID，并存入 `localStorage`。

2.  **API请求封装**:
    *   使用 `axios` 拦截器或一个统一的API请求函数，在每个发往后端的请求的HTTP Header中自动附加 `X-Session-Id`。

3.  **UI变更**:
    *   在界面上添加一个输入框或下拉菜单，允许用户设置会话的有效时间（例如，“24小时后销毁数据”）。
    *   当用户设置时间后，调用 `POST /api/session` 接口，将当前 `session_id` 和期望的有效期发送给后端。

---

#### **6. 实施步骤总结**

1.  **后端**:
    a.  更新 `src/db/schema.ts` 文件，添加 `sessionsTable` 并修改 `fileTable`。
    b.  执行 `npx drizzle-kit generate` 生成迁移文件，并使用 `npx drizzle-kit push` 更新数据库。
    c.  创建 `POST /api/session` 路由。
    d.  创建 `GET /api/cron/cleanup-sessions` 路由。
    e.  修改所有现有的API路由，添加 `session_id` 的获取和使用逻辑。
    f.  在项目根目录创建 `vercel.json` 并配置Cron Job。
2.  **前端**:
    a.  实现 `session_id` 的本地生成和存储逻辑。
    b.  封装API请求，自动添加 `X-Session-Id` 头。
    c.  开发用于设置会话过期时间的UI组件，并连接到 `POST /api/session` 接口。
