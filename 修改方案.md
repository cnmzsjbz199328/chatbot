# 修改方案.md

## 目标：为项目实现向量数据的删除与修改功能

### 背景

当前项目缺少对已上传文件及其关联向量数据的管理能力。本方案旨在通过改造现有流程，并新增功能，来实现对指定文件及其所有相关向量数据的可靠删除。修改功能将通过“先删除，后上传”的模式实现。

### 核心策略

我们将为每个上传的文件生成一个唯一的SQL数据库ID，并将此ID作为元数据（metadata）注入到所有由该文件产生的Pinecone向量块中。这样就建立了从文件到其所有向量块的直接关联，为精确删除提供了可能。

---

## 第一步：改造数据库操作，返回文件ID

**状态：** 已完成并验证。

**目标：** 修改现有的数据库插入函数，使其在创建文件记录后，能返回该记录的唯一ID。

**实施计划：**

1.  **定位文件：** 我们需要修改位于 `src/db/index.ts` 文件中的 `insertFile` 函数。
2.  **修改函数逻辑：** Drizzle ORM的 `insert` 方法可以配置一个 `.returning()` 子句来返回新插入行的数据。我们将修改 `insertFile` 函数，使其返回新创建记录的 `id`。

---

## 第二步：将文件ID关联到向量元数据

**目标：** 在 `upload/route.ts` 中，获取第一步返回的 `fileId`，并将其作为元数据（metadata）添加到所有相关的Pinecone向量块中。

**实施计划：**

1.  **重构代码逻辑：** 将 `insertFile` 的调用从辅助函数 `processAndEmbedChunks` **移动**到主函数 `POST` 中。这使得我们可以在处理向量数据**之前**就获取到 `fileId`。
2.  **传递 `fileId`：** `POST` 函数将把获取到的 `fileId` 作为参数传递给 `processAndEmbedChunks` 函数。
3.  **注入元数据：** 在 `processAndEmbedChunks` 函数中，修改创建Pinecone记录的逻辑，把接收到的 `fileId` 添加到每个向量的 `metadata` 对象中。

**伪代码示例：**
```typescript
// src/app/api/upload/route.ts

// 在 POST 函数中
const newFile = await insertFile(file.name, Md5.hashStr(file.name));
const fileId = newFile[0].id;
// ...
await processAndEmbedChunks(allChunks, fileId); // 传递ID

// processAndEmbedChunks 函数签名
async function processAndEmbedChunks(chunks: string[], fileId: number) {
  // ...
  const records = chunks.map((c, i) => ({
      id: Md5.hashStr(c),
      values: allVectors[i],
      metadata: { 
          text: c,
          file_id: fileId // 注入元数据
      }
  }));
  // ...
}
```

**验证方案：**

在修改完成后，上传一个新文件。然后登录Pinecone后台管理界面，查看最新上传的向量数据，确认其 `metadata` 中包含了正确的 `file_id` 字段和对应的数值。

---

## 第三步：创建文件删除API接口

**状态：** 已完成并验证。

**目标：** 创建一个后端API接口，用于接收删除请求并执行删除操作。

**实施计划：**

1.  **创建动态路由文件：** 创建新文件 `src/app/api/files/[id]/route.ts`。
2.  **实现 `DELETE` 方法：** 在该文件中，导出一个异步函数 `DELETE`。
3.  **获取文件ID：** 从URL路径参数中解析出要删除的文件ID。
4.  **执行删除：**
    a.  **删除Pinecone向量：** 调用Pinecone的 `delete` API，并使用元数据过滤器 (`{ filter: { file_id: id } }`) 来删除所有关联的向量。
    b.  **删除SQL记录：** 创建并调用一个新的数据库函数（例如 `deleteFileById`），根据ID从 `fileTable` 中删除文件记录。

**伪代码示例：**
```typescript
// src/app/api/files/[id]/route.ts
import { NextResponse } from "next/server";
import { pc } from "@/lib/pinecone";
import { deleteFileById } from "@/db";

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  const fileId = parseInt(params.id, 10);

  // 1. Delete vectors from Pinecone
  await pc.index('chatbot').delete({
    filter: { file_id: fileId }
  });

  // 2. Delete record from PostgreSQL
  await deleteFileById(fileId);

  return NextResponse.json({ success: true });
}
```

**验证方案：**

在第四步完成后，通过前端页面点击删除按钮来触发此接口，然后检查PostgreSQL数据库和Pinecone后台，确认相关数据均已被删除。

---

## 第四步：实现前端删除功能

**目标：** 在前端文件列表中添加“删除”按钮，并实现点击后调用API删除文件的功能。

**实施计划：**

1.  **修改组件：** 打开 `src/components/UploadContainer.tsx` 文件。
2.  **添加删除按钮：** 在渲染文件列表的 `map` 循环中，为每一项添加一个删除按钮。
3.  **创建删除`mutation`：** 使用 `@tanstack/react-query` 的 `useMutation` 创建一个新的 `deleteMutation`。
    a.  `mutationFn` 将接收 `fileId` 作为参数，并调用 `axios.delete(`/api/files/${fileId}`)`。
    b.  在 `onSuccess` 回调中，调用 `queryClient.invalidateQueries({ queryKey: ['files'] })` 来刷新文件列表。
4.  **绑定点击事件：** 为删除按钮的 `onClick` 事件绑定一个函数，该函数调用 `deleteMutation.mutate(file.id)`。

**伪代码示例：**
```typescript
// src/components/UploadContainer.tsx

// ...
const { mutate: deleteFile } = useMutation({
  mutationFn: (fileId: number) => axios.delete(`/api/files/${fileId}`),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['files'] });
  },
});

// ... 在JSX中
{files?.data.map((file: FileModel) => (
  <li key={file.id}>
    {file.file_name}
    <button onClick={() => deleteFile(file.id)}>Delete</button>
  </li>
))}
```

**验证方案：**

在UI界面上点击一个文件的删除按钮。预期行为是该文件会从列表中消失。

---

## 第五步：更新项目文档

**目标：** 在项目主 `README.md` 中，更新API文档部分，加入关于新删除接口的说明。

**实施计划：**

1.  打开 `README.md` 文件。
2.  在 `API Endpoints` 章节下，添加一行 `DELETE /api/files/[id]` 并附上简要说明。

**验证方案：**

查看 `README.md` 文件，确认内容已更新。